# Java
<details>
<summary>다른 언어와 비교하였을 때 Java의 장점에 대해 설명해주세요.</summary>

<br>

- 플랫폼에 구애받지 않고 JVM이 설치된 모든 장치에서 동작한다.
    - 운영체제의 영향이 없이 동작하며 멀티 스레드를 지원하지 않는 OS에서도 자바 언어를 사용하면 멀티스레드를 구현할 수 있다.
- 객체지향 언어이다.
- 수많은 개발자와 레퍼런스가 있어 문제가 발생하였을 때, 트러블슈팅을 하기 쉽다.
- 디버깅하는 실행 속도를 개선하기 위해 JIT 컴파일러가 사용된다.
- GC(가비지 컬렉션)이 존재하여 객체의 소멸을 스스로 해준다.

단점

- 실행 속도가 다른 언어보다 느리다.
- 다른 언어와 비교했을 때 소스코드의 길이가 길다.
- GC가 언제 어떻게 작동될지 아무도 모르기 때문에 중간에 끊김 현상이 발생할 수 있어 실시간 응용 시스템으로 부적합하다

[Java의 장단점](https://okeybox.tistory.com/131)

</details>


<details>
<summary>가용성, 고가용성</summary>

<br>

**가용성**

- 가용성은 서버와 네트워크 등의 다양한 시스템이 정상적으로 사용 가능한 정도를 의미한다.
- 식으로 표현하면 `정상 시간 / 전체 사용시간`이다.
    - 해당 값이 높을 수록 가용성이 높은 프로그램이다.

**고가용성**

- 서버와 네트워크 등의 시스템이 오랜 기간동안 지속적으로 장애없이 정상 운영이 가능한 성질을 의미한다.

</details>


<details>
<summary>자바의 버전별 특징에 대해 설명해주세요</summary>

<br>

자바8: 람다, 인터페이스의 default method, stream api, **Null 처리 Optional** 등이 추가됨

자바9: 인터페이스 내에서 private 메서드 사용이 가능

자바10: 타입 추론 변수 var 추가, 병렬 처리 GC, 개별 스레드로 분리된 Stop the world등이 추가됐다.

- 기존에는 Stop-The-World 가 발생하면 GC 를 실행하는 쓰레드를 제외한 나머지 쓰레드는 모두 작업을 멈춘다. GC 작업을 완료한 이후에야 중단했던 작업을 다시 시작한다. 근데 이게 개별 쓰레드로 분리되어서 Stop-The-World 시간이 개선된것 같다.

자바 11: String 메서드 추가(`strip()`, `isBlank()`, `lines()`, `repeat()`), 람다 파라미터로 var사용

자바 12~14: 스위치 표현식 개선 (표현식에서 값 반환 가능)

[java 버전별 차이 & 특징](https://velog.io/@ljo_0920/java-%EB%B2%84%EC%A0%84%EB%B3%84-%EC%B0%A8%EC%9D%B4-%ED%8A%B9%EC%A7%95)

</details>


<details>
<summary>객체지향 설계 5원칙(SOLID)란?</summary>

<br>

SRP(Single Responsibility Principle, 단일 책임 원칙)

- 작성된 클래스는 하나의 기능만 가지며 클래스가 제공하는 모든 서비스는 그 하나의 책임을 수행하는데 집중되어야 한다.

OCP(Open Close Principle, 개방폐쇄의 원칙)

- 소프트웨어의 구성요소는 확장에 열려있고 변경에는 닫혀있다. 변경을 위한 비용은 가능하면 줄이고 확장을 위한 비용은 극대화해야한다.
- 요구사항의 변경이나 추가 사항이 발생하여도 기존 구성요소는 수정이 일어나지 말아야 하며, 기존 구성요소를 쉽게 확장해서 재사용할 수 있어야 한다.

LSP(The Liskov Substitution Principle, 리스코프 치환의 원칙)

- 서브 타입은 언제나 기반 타입과 호환될 수 있어야 한다.
- 상속은 궁극적으로 다형성을 통한 확장성을 목표로 한다. LSP도 서브클래스가 확장에 대한 인터페이스를 준수해야함을 의미한다.

ISP(Interface Segregation Principle, 인터페이스 분리의 원칙)

- 한 클래스는 자신이 사용하지 않는 인터페이스는 구현하지 말아야 한다. → 다른 크랠스에 종속될 때는 가능한 최소한의 인터페이스만을 사용해야 한다.

DIP(Dependency Inversion Principle, 의존성 역전의 원칙)

- 하위 레벨 모듈의 변경이 상위 레벨 모듈의 변경을 요구하는 위치 관계를 끊는 의미의 역전이다.
- **저수준 모듈이 고수준 모듈에 의존하게 되는 것을 의미한다.**
- 추상화에 의존하고 구체화에 의존하면 안 된다. 즉, 하위 모듈이 상위 모듈에서 정의한 추상 타입(인터페이스)에 의존하여야 한다.

</details>
